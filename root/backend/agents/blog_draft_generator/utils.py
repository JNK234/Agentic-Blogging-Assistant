"""
Utility functions for the Blog Draft Generator.
"""
import logging
import re
import json
from typing import Dict, List, Optional, Any
from datetime import datetime
from root.backend.services.vector_store_service import VectorStoreService
from root.backend.agents.blog_draft_generator.state import ContentReference, CodeExample

logging.basicConfig(level=logging.INFO)

def extract_code_blocks(content: str) -> List[Dict[str, str]]:
    """
    Extracts code blocks from markdown content.
    
    Args:
        content: Markdown content with code blocks
        
    Returns:
        List of dictionaries with language and code
    """
    code_blocks = []
    matches = re.findall(r'```(\w+)?\n(.*?)```', content, re.DOTALL)
    
    for language, code in matches:
        language = language or "text"
        code_blocks.append({
            "language": language,
            "code": code.strip()
        })
    
    return code_blocks

def format_content_references(references: List[ContentReference]) -> str:
    """
    Formats content references for use in prompts.
    
    Args:
        references: List of ContentReference objects
        
    Returns:
        Formatted string of references
    """
    if not references:
        return "No relevant content available."
    
    formatted = []
    for ref in references:
        formatted.append(
            f"CONTENT ({ref.category}, Relevance: {ref.relevance_score}):\n{ref.content}"
        )
    
    return "\n\n".join(formatted)

def extract_section_metrics(section_content: str) -> Dict[str, float]:
    """
    Extracts metrics from a section's content.
    
    Args:
        section_content: The content of the section
        
    Returns:
        Dictionary of metrics
    """
    metrics = {
        "word_count": len(section_content.split()),
        "code_block_count": len(re.findall(r'```\w*\n', section_content)),
        "heading_count": len(re.findall(r'^#{2,}\s+.+$', section_content, re.MULTILINE)),
        "list_item_count": len(re.findall(r'^[\s]*[-*]\s+.+$', section_content, re.MULTILINE))
    }
    
    return metrics

def store_blog_in_vector_store(
    blog_content: str, 
    title: str, 
    sections: List[Dict], 
    project_name: Optional[str] = None
) -> Optional[str]:
    """
    Stores the generated blog in the vector store for future reference.
    
    Args:
        blog_content: The full blog content
        title: The blog title
        sections: List of section dictionaries
        project_name: Optional project name
        
    Returns:
        Content hash if successful, None otherwise
    """
    try:
        vector_store = VectorStoreService()
        
        # Create chunks from sections
        chunks = []
        metadata = []
        
        # Add title and metadata as first chunk
        chunks.append(f"# {title}\n\nBlog post generated by Agentic Blogging Assistant")
        
        # Create metadata for the first chunk
        base_metadata = {
            "content_type": "blog",
            "title": title,
            "project_name": project_name,
            "generated_at": datetime.now().isoformat(),
            "file_type": "markdown"
        }
        
        metadata.append(base_metadata)
        
        # Add each section as a chunk
        for i, section in enumerate(sections):
            chunks.append(f"## {section['title']}\n\n{section['content']}")
            
            section_metadata = base_metadata.copy()
            section_metadata.update({
                "section_title": section["title"],
                "section_index": i
            })
            
            metadata.append(section_metadata)
        
        # Generate content hash
        content_hash = vector_store.compute_content_hash(blog_content, title)
        
        # Store in vector store
        vector_store.store_content_chunks(
            chunks=chunks,
            metadata=metadata,
            content_hash=content_hash
        )
        
        logging.info(f"Blog '{title}' stored in vector store with hash {content_hash}")
        return content_hash
        
    except Exception as e:
        logging.error(f"Error storing blog in vector store: {e}")
        return None

def parse_json_safely(json_str: str, default_value: Any = None) -> Any:
    """
    Safely parses JSON with fallback to default value.
    
    Args:
        json_str: JSON string to parse
        default_value: Default value to return if parsing fails
        
    Returns:
        Parsed JSON or default value
    """
    try:
        return json.loads(json_str)
    except json.JSONDecodeError:
        logging.warning("Failed to parse JSON, returning default value")
        return default_value

def format_code_examples(code_examples: List[CodeExample]) -> str:
    """
    Formats code examples for inclusion in the blog.
    
    Args:
        code_examples: List of CodeExample objects
        
    Returns:
        Formatted string of code examples with explanations
    """
    if not code_examples:
        return ""
    
    formatted = []
    for example in code_examples:
        formatted.append(
            f"### {example.description}\n\n"
            f"{example.explanation}\n\n"
            f"```{example.language}\n{example.code}\n```"
        )
        
        if example.output:
            formatted.append(f"Output:\n```\n{example.output}\n```")
    
    return "\n\n".join(formatted)

def generate_table_of_contents(sections: List[Dict]) -> str:
    """
    Generates a table of contents from section information.
    
    Args:
        sections: List of section dictionaries with titles
        
    Returns:
        Markdown formatted table of contents
    """
    toc = ["## Table of Contents"]
    
    for i, section in enumerate(sections):
        toc.append(f"{i+1}. [{section['title']}](#section-{i+1})")
    
    return "\n".join(toc)
